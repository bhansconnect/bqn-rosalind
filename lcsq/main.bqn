#!/usr/bin/env bqn

aâ€¿bâ†âˆ¾Â¨1âŠ¸â†“Â¨1â†“(âŠ¢âŠ”Ëœ+`âˆ˜(âˆ¨Â´âˆ˜â¥Šâˆ˜âˆŠËœâŸœ'>'Â¨))â€¢FLines "rosalind_lcsq.txt" 

# My original super slow solution.
#Mâ†âŠ£âŸ(>â—‹â‰ )
#â€¢Show Â¯1âŠ‘Â¯1âŠ(M`M`Ë˜)âˆ˜(dâˆ¾ËœÂ¨Ë˜(Â»Â»Ë˜)){ğ•Šâˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•©} (M`M`Ë˜)dâ†a(=âŒœâ¥ŠÂ¨âŠ£)b

# I was having a really hard time figuring out how to implement this efficiently in an array world.
# So I looked it up to try and just use parts/understand better.
# This is the solution from rosetta code.
# It is actually quite elegant.
# The core thing I missed is that instead of repeating something many times over the matrix
# It is possible to scan across the matrix calculating intermediater results as you go.
# Did not think that was the proper mapping for array oriented programming so I never looked into it.
# Hopefully these learnings will translate to other problems.
# Might also try to make my own unique solution to this in the future.

LCS â† Â¯1 âŠ‘ "" <âŠ¸âˆ¾ ""Â¨âˆ˜âŠ¢ âŠ£âŸ(>â—‹â‰ ){ğ•©ğ”½Â¨ğ”½`ğ•¨âˆ¾Â¨""<âŠ¸Â»ğ•©}Ë (=âŒœâ¥ŠÂ¨âŠ£)âŸœâŒ½
â€¢Out a LCS b
